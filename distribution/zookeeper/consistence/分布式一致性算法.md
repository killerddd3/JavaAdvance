[TOC]

# 分布式一致性算法

#### 理解一致性

1. 多份数据保持一致。多份相同的数据，在一处修改，保证多份保持一致。

   ![image-20191002154437624](assets/image-20191002154437624.png)

2. 一个业务变更多份不同的数据，保持整体一致。如下单需增加订单数据，扣减库存。

   ![image-20191002154601811](assets/image-20191002154601811.png)

#### 什么情况会产生不一致

1. 异常操作导致操作不能成功。

   ![image-20191002154745580](assets/image-20191002154745580.png)

   2. 网络分区。

      ![image-20191002154820626](assets/image-20191002154820626.png)

      3. 应用故障。

         ![image-20191002154855967](assets/image-20191002154855967.png)

         网络分区，故障，异常导致多个操作的部分操作不能成功。

         网络分区，故障，异常能避免吗？如何保证a1成功，b1失败时的一致性？将更新操作分为预操作，提交/回滚两个阶段，行吗？要回滚，提交，需要什么？undo，redo日志。

      #### 2PC

      1. 将提交操作分为准备(投票)，提交(完成)两个阶段来达成一致性的算法。主要用于事务管理，分布式一致性。

         ![image-20191002155331991](assets/image-20191002155331991.png)

      2. P1：准备阶段(投票阶段)。

         ![image-20191002155519181](assets/image-20191002155519181.png)

         * 协调者询问各参与者是否可以提交，等待所有参与者给出响应。

         * 参与者执行事务操作到等待提交指令的点，这个过程中记录redo，undo日志。

           ![image-20191002155846114](assets/image-20191002155846114.png)

         * 参与者响应是否准备好提交的结果给协调者，并阻塞等待协调者的下一步指令。
      
         * 协调者接收到所有参与者的响应，如果超时未收到响应，当abort处理。有一个abort，则下一步时回滚。
         
      3. P2提交阶段。
      
         ![image-20191002160128064](assets/image-20191002160128064.png)
      
         * 协调者向所有参与者发出提交或回滚消息。
      
           ![image-20191002160313499](assets/image-20191002160313499.png)
      
         * 参与者执行提交/回滚，释放占用锁等资源，并作出响应。
      
           ![image-20191002160413932](assets/image-20191002160413932.png)
      
      4. 消息流。
      
         ![image-20191002160551317](assets/image-20191002160551317.png)
      
      5. 不足。
      
         ![image-20191002161101944](assets/image-20191002161101944.png)
      
         * 阻塞。准备阶段。协调者等待参与者，参与者等待协调者。准备完成时，如果协调者宕机，所有参与者都将一直阻塞。
      
           ![image-20191002161121275](assets/image-20191002161121275.png)
      
         * 不一致。commit提交阶段。协调者向所有参与者发出提交或回滚消息。参与者宕机，将接收不到提交消息，会出现不一致，需要人工干预。
   

#### 3PC

2PC当协调者宕机时，网络分区时将一直阻塞。3PC增加预提交阶段+超时限制来改进这个问题。

![image-20191002162145385](assets/image-20191002162145385.png)

1. 3PC在什么情况下会出现不一致。部分preCommit失败，协调者宕机，等待超时后，preCommit成功者自提交。
2. 3PC的应用难点，超时时长该设置为多长。

#### Paxos

![image-20191002163037645](assets/image-20191002163037645.png)

![image-20191002163052028](assets/image-20191002163052028.png)

此时集群中的节点就不一致了。根本原因是多个客户端都可以进行写操作。所以要引入Leader节点，所有写操作都转发到Leader节点进行，然后再同步给其它节点。

![image-20191002163214549](assets/image-20191002163214549.png)

![image-20191002163228654](assets/image-20191002163228654.png)

问题：Leader的负载高，单点故障，真个集群不可用。

1. 三种角色。

   ![image-20191002163437375](assets/image-20191002163437375.png)

   * Proposer：提议者，负责提议，提出想要达成一致的value的提案。
   * Acceptor：接收者，对提案投票，决定是否接受此value提案。
   * Leaner：学习者，不参与投票，学习投票决定的提案。

   一个节点既可以是提议者，也可以是投票者。

2. 提案：提案编号，唯一，保证全局递增，体现提案的先后顺序；更新值。

3. 写流程，两阶段。

   * 准备阶段(投票阶段)：
     * 提议者提出提案给接收者。
     * 接收者如果同意该提案，做出promise响应，并不再Accept比当前提案号低的提案。
     * 提议者收到超过半数的响应，则进入下一阶段，否则重新提案。
   * 接受变更阶段(提交阶段):
     * 提议者向接收者发送Accept消息。
     * 接收者比较Accept消息中的提案号，如果比自己当前已promise的提案号低，则回应Nack(当前自己promise的提案号)，否则Accept，广播Accepted。

   ![image-20191002165007106](assets/image-20191002165007106.png)

4. 同一提案者，提议者2，提议者1先后被批准，正常场景。

   ![image-20191003083117833](assets/image-20191003083117833.png)

5. 接收者3与提议者2失联，接受者1与提议者1失联，异常场景。

   ![image-20191003083730872](assets/image-20191003083730872.png)

6. 读流程。

   ![image-20191003084254396](assets/image-20191003084254396.png)

   

* 接收客户端请求的节点，向集群广播获取大家的当前值。
* 接收到过半相同的值，则返回改值，如果本地的值不同，则更新为多数值。
* 如果得不到过半的相同值，则读取失败。

#### 其他

1. ZAB
2. RAFT：http://thesecretlivesofdata.com/raft